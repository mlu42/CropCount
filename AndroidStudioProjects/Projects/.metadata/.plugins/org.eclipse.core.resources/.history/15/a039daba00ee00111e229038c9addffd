package ipcm.tool.kit;

import java.util.ArrayList;
import java.util.Date;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

public class DataHelper {
	//Declaring constants for the database name, table name,
	//and the version of the database
	private static final String DATABASE_NAME = "myDatabase.db";
	private static final String TIMES_TABLE = "times";
	private static final String CROP_MANAGER_TABLE = "articles";
	private static final String TWEET_TABLE = "tweets";
	private static final String VIDEO_TABLE = "videos";
	private static final String PLAYLIST_TABLE = "playlists";
	private static final int DATABASE_VERSION = 1;

	//The name and column index of each column in the times table
	public static final String KEY_ID = "_id";
	public static final int ID_COLUMN = 0;
	public static final String KEY_TIME = "time";
	public static final int TIME_COLUMN = 1;
	
	//The name and column index of each column in the article table
	//public static final String KEY_ID = "_id";
	//public static final int ID_COLUMN = 0;
	public static final String KEY_TITLE = "title";
	public static final int TITLE_COLUMN = 1;
	public static final String KEY_DATE = "date";
	public static final int DATE_COLUMN = 2;
	public static final String KEY_ARTICLE_TIME = "time";
	public static final int ARTICLE_TIME_COLUMN = 3;
	public static final String KEY_LINK = "link";
	public static final int LINK_COLUMN = 4;
	
	//The name and column index of each column in the tweet table
	//public static final String KEY_ID = "_id";
	//public static final int ID_COLUMN = 0;
	public static final String KEY_USER = "user";
	public static final int USER_COLUMN = 1;
	public static final String KEY_TEXT = "text";
	public static final int TEXT_COLUMN = 2;
	public static final String KEY_TWEETLINK = "tweetlink";
	public static final int TWEETLINK_COLUMN = 3;
	
	//The name and column index of each column in the video table
	//public static final String KEY_ID = "_id";
	//public static final int ID_COLUMN = 0;
	//public static final String KEY_TITLE = "title";
	//public static final int TITLE_COLUMN = 1;
	public static final String KEY_PLAYLIST = "playlist";
	public static final int PLAYLIST_COLUMN = 2;
	public static final String KEY_URL = "url";
	public static final int URL_COLUMN = 3;
	public static final String KEY_THUMBNAILURL = "thumbnailurl";
	public static final int THUMBNAILURL_COLUMN = 4;
	
	//The name and column index of each column in the playlist table
	//public static final String KEY_ID = "_id";
	//public static final int ID_COLUMN = 0;
	//public static final String KEY_TITLE = "title";
	//public static final int TITLE_COLUMN = 1;
	public static final String KEY_FEEDURL = "feedurl";
	public static final int FEEDURL_COLUMN = 2;
	
	//Rows
	public static final int ROW_CROPMANAGER = 1;
	public static final int ROW_TWITTER = 2;
	public static final int ROW_ALLPLAYLISTS = 3;
	public static final int ROW_PESTS = 4;
	public static final int ROW_CROPHEALTH = 5;
	public static final int ROW_INVASIVEWEEDS = 6;	

	//SQL statement to create a new database
	private static final String PLAYLIST_TABLE_CREATE =
		"CREATE TABLE " + PLAYLIST_TABLE + "(" +
		KEY_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
		KEY_TITLE + " TEXT, " +
		KEY_FEEDURL + " TEXT" +
		");";
	
	private static final String VIDEO_TABLE_CREATE = 
		"CREATE TABLE " + VIDEO_TABLE + "(" +
		KEY_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
		KEY_TITLE + " TEXT, " +
		KEY_PLAYLIST + " TEXT, " +
		KEY_URL + " TEXT, " +
		KEY_THUMBNAILURL + " TEXT" +
		");";
	
	private static final String TIMES_TABLE_CREATE = 
		"CREATE TABLE " + TIMES_TABLE + "(" +
		KEY_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
		KEY_TIME + " INTEGER" +
		");";
	
	private static final String CROP_MANAGER_TABLE_CREATE = 
		"CREATE TABLE " + CROP_MANAGER_TABLE + "(" +
		KEY_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
		KEY_TITLE + " TEXT, " +
		KEY_DATE + " TEXT, " +
		KEY_ARTICLE_TIME + " TEXT, " +
		KEY_LINK + " TEXT" +
		");";
	
	private static final String TWEET_TABLE_CREATE =
		"CREATE TABLE " + TWEET_TABLE + "(" +
		KEY_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
		KEY_USER + " TEXT, " +
		KEY_TEXT + " TEXT, " +
		KEY_TWEETLINK + " TEXT" +
		");";
		

	//Variable to hold the database instance
	private SQLiteDatabase db;
	//Context of the application using the database
	private final Context context;
	//Database open/upgrade helper;
	private DBHelper dbHelper;
    
	// Constructor for a DataHelper
	// @param _context: the context in which the DataHelper will operate
	public DataHelper(Context _context)
	{
		context = _context;
		dbHelper = new DBHelper(context);
	}
	
	//The following two methods are interchangeable.
	//I just use them separately because it helps keep
	//things in order a little better.
	
	//Opens a DataHelper that is writable
	public DataHelper openForWrite() throws SQLException
	{
		db = dbHelper.getWritableDatabase();
		return this;
	}
	
	//Opens a DataHelper that is readable
	public DataHelper openForRead() throws SQLException
	{
		db = dbHelper.getReadableDatabase();
		return this;
	}
    
	//Closes the database.
	public void close()
	{
		db.close();
	}

	/*
	 * Inserts a quote into the database.
	 * @param n: the name of the person who said the quote.
	 * @param q: the quote.
	 */
	public long insertTime()
	{
		openForWrite();
		
		ContentValues price = new ContentValues();		
		price.put(KEY_TIME, 0);
		
		close();
		return db.insert(TIMES_TABLE, null, price);
	}
    
	/*
	 * Removes the selected quote from the database
	 * @param _rowIndex: the rowIndex of the quote to be removed.
	 */
	public void removeTime(long _rowIndex)
	{
		openForWrite();
		db.delete(TIMES_TABLE, KEY_ID + "=" + _rowIndex, null);
		close();
	}
	
	//Removes all of the quotes from the database.
	public void removeAllTimes()
	{
		openForWrite();
		db.delete(TIMES_TABLE, null, null);
		close();
	}
    
	//Returns a cursor over the entire database.
	public Cursor getAllTimes()
	{
		openForWrite();
		Cursor q = db.query(TIMES_TABLE,
				null, null, null, null, null, null);		
		q.moveToFirst();
		close();
		return q;
	}
    
	//Returns a cursor over the selected quote.
	//@param _rowIndex: the rowIndex of the quote to be returned.
	public Cursor getCursorTime(int _rowIndex)
	{
		openForWrite();
		
		Cursor c = db.query(TIMES_TABLE, null, KEY_ID + "=" + _rowIndex, 
				null, null, null, null);
		
		close();
		return c;	
	}	

	public long getTime(int _rowIndex)
	{
		openForWrite();
		
		Cursor c = getAllTimes();
		c.moveToPosition(_rowIndex - 1);
		long time = c.getLong(TIME_COLUMN);
		
		c.close();		
		close();
		return time;
	}
	
	public long getTimeSince(int _rowIndex)
	{
		openForWrite();
		long time = System.currentTimeMillis();
		long timeSince = getTime(_rowIndex);
		close();
		
		return time - timeSince;
	}
	
	public boolean updateTime(long _rowIndex)
	{
		openForWrite();
		ContentValues time = new ContentValues();
		time.put(KEY_TIME,  System.currentTimeMillis());
		db.update(TIMES_TABLE, time, KEY_ID + "=" + _rowIndex, null);
		close();
		return true;
	}
	
	public void saveCropManagerArticles(ArrayList<CropManagerArticle> _articles)
	{
		db.delete(CROP_MANAGER_TABLE, null, null);
		
		for(CropManagerArticle article: _articles)
		{
			ContentValues art = new ContentValues();
			
			art.put(KEY_TITLE, article.getTitle());
			art.put(KEY_DATE, article.getDate());
			art.put(KEY_LINK, article.getLink());
			
			db.insert(CROP_MANAGER_TABLE, null, art);
		}
	}
	
	public void saveTweets(ArrayList<Tweet> _tweets)
	{
		db.delete(TWEET_TABLE, null, null);
		
		for(Tweet tweet: _tweets)
		{
			ContentValues twee = new ContentValues();
			
			twee.put(KEY_USER, tweet.getUser());
			twee.put(KEY_TEXT, tweet.getText());
			twee.put(KEY_TWEETLINK, tweet.getLink());
			
			db.insert(TWEET_TABLE, null, twee);
		}
	}
	
	public void saveAllYoutubeVids(ArrayList<YoutubeVideo> _videos)
	{
		openForWrite();
		
		db.delete(VIDEO_TABLE, null, null);
		
		for(YoutubeVideo video: _videos)
		{
			ContentValues vid = new ContentValues();
			
			vid.put(KEY_TITLE, video.getName());
			vid.put(KEY_PLAYLIST, video.getPlaylist());
			vid.put(KEY_URL, video.getUrl());
			vid.put(KEY_THUMBNAILURL, video.getThumbnailLink());
			
			db.insert(VIDEO_TABLE, null, vid);
		}
		
		close();
	}
	
	public void saveAllPlaylists(ArrayList<Playlist> _playlists)
	{
		db.delete(PLAYLIST_TABLE, null, null);
		
		for(Playlist playlist: _playlists)
		{
			ContentValues list = new ContentValues();
			
			list.put(KEY_TITLE, playlist.getTitle());
			list.put(KEY_FEEDURL, playlist.getUrl());
			
			db.insert(PLAYLIST_TABLE, null, list);
		}
	}
	
	public ArrayList<Playlist> getAllPlaylists()
	{
		ArrayList<Playlist> playlists = new ArrayList<Playlist>();
		
		Cursor c = db.query(PLAYLIST_TABLE, null, null, null, null, null, null);
		c.moveToFirst();
		
		while(!c.isAfterLast())
		{
			Playlist list = new Playlist(c.getString(TITLE_COLUMN), c.getString(FEEDURL_COLUMN));
			playlists.add(list);
			c.moveToNext();
		}
		
		c.close();		
		return playlists;
	}
	
	public ArrayList<YoutubeVideo> getAllYoutubeVideos()
	{
		Cursor c = db.query(VIDEO_TABLE, null, null, null, null, null, null);
		ArrayList<YoutubeVideo> videos = new ArrayList<YoutubeVideo>();
		c.moveToFirst();
		
		while(!c.isAfterLast())
		{
			YoutubeVideo vid = new YoutubeVideo(c.getString(TITLE_COLUMN), c.getString(PLAYLIST_COLUMN), c.getString(URL_COLUMN), c.getString(THUMBNAILURL_COLUMN));
			videos.add(vid);
			c.moveToNext();
		}
		
		c.close();
		return videos;
	}
	
	public ArrayList<CropManagerArticle> getCropManagerArticles()
	{
		Cursor c = db.query(CROP_MANAGER_TABLE, null, null, null, null, null, null);
		ArrayList<CropManagerArticle> articles = new ArrayList<CropManagerArticle>();
		c.moveToFirst();
		
		while(!c.isAfterLast())
		{
			CropManagerArticle art = new CropManagerArticle(c.getString(TITLE_COLUMN), c.getString(DATE_COLUMN), c.getString(LINK_COLUMN));
			articles.add(art);
			c.moveToNext();
		}
		
		c.close();
		return articles;
	}
	
	public ArrayList<Tweet> getTweets()
	{
		Cursor c = db.query(TWEET_TABLE, null, null, null, null, null, null);
		ArrayList<Tweet> tweets = new ArrayList<Tweet>();
		c.moveToFirst();
		
		while(!c.isAfterLast())
		{
			Tweet twee = new Tweet(c.getString(USER_COLUMN) + ": "+ c.getString(TEXT_COLUMN), c.getString(TWEETLINK_COLUMN));
			tweets.add(twee);
			c.moveToNext();
		}
		
		c.close();
		return tweets;
	}

	private static class DBHelper extends SQLiteOpenHelper
	{
		// Constructor for a DBHelper
		// @param _context: the context in which the DataHelper will operate
		public DBHelper(Context context)
		{
			super(context, DATABASE_NAME, null, DATABASE_VERSION);
		}
		
		//Called when no database exists on disk and that helper class
		//needs to create a new one.
		@Override
		public void onCreate(SQLiteDatabase _db)
		{
			_db.execSQL(TIMES_TABLE_CREATE);
			_db.execSQL(CROP_MANAGER_TABLE_CREATE);
			_db.execSQL(TWEET_TABLE_CREATE);
			_db.execSQL(VIDEO_TABLE_CREATE);
			_db.execSQL(PLAYLIST_TABLE_CREATE);
		}

		//Called when there is a database version mismatch meaning that the version
		//of the database on disk needs to be upgraded to the current version.
		@Override
		public void onUpgrade(SQLiteDatabase _db, int _oldVersion, int _newVersion)
		{
			//Log the version upgrade
			Log.w("TaskDataHelper", "Upgrading from version " + _oldVersion 
					+ " to " +
					+ _newVersion + ", which will destroy all old data");

			//Upgrade the existing database to conform to the new version.
			//Multiple previous versions can be handled by comparing _oldVersion
			//and _newVersion values.
			_db.execSQL("DROP TABLE IF EXISTS" + TIMES_TABLE);
			//Create a new one.
			onCreate(_db);
		}
	}
}